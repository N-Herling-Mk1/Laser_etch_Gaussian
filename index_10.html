<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Laser Etch — Gaussian Loop + MAX_PASSES + MEGA SPARKS</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{ --bg:#0a0c10; --slab:#0c0d10; --frame:#13151a; }
  html,body{margin:0;height:100%;background:var(--bg);color:#e9fff5;font:14px/1.25 ui-monospace,Consolas,Menlo,monospace}
  .wrap{display:grid;place-items:center;min-height:100%}
  canvas{display:block;width:min(100vw,1280px);height:auto;max-height:92vh;border-radius:12px;box-shadow:0 18px 60px rgba(0,0,0,.45)}
  .hud{position:fixed;left:50%;top:10px;transform:translateX(-50%);
        background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.08);
        padding:6px 10px;border-radius:8px;color:#bfffe9;font:13px Consolas,monospace;}
  .passbig{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
        font:700 52px/1 Consolas,monospace;color:#bfffe9;opacity:.15;pointer-events:none;text-shadow:0 0 18px rgba(80,255,180,.35);}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="c" width="1280" height="720"></canvas>
</div>
<div class="hud" id="hud">Pass: 1 / 3</div>
<div class="passbig" id="passbig">PASS 1</div>

<script>
(() => {
  // ====== GLOBAL: set how many passes ======
  const MAX_PASSES = 3; // set to 3 (or any number). After that, it stops.

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const hud = document.getElementById('hud');
  const passBig = document.getElementById('passbig');

  // Layers
  const art  = mk(W,H), artCtx  = art.getContext('2d');
  const slab = mk(W,H), slabCtx = slab.getContext('2d');
  const glow = mk(W,H), glowCtx = glow.getContext('2d'); // additive layer (laser + sparks)
  const etch = mk(W,H), etchCtx = etch.getContext('2d'); // accumulates etched Gaussian

  // ---- Tunables ----
  const P = {
    speed: 0.25,      // passes per second
    kerf: 6,
    powerFloor: 0.40,
    revealLen: 40,
    revealWidth: 22,
  };

  const COL = {
    slab:'#0c0d10',
    frame:'#13151a',
    laserCore:'rgb(230,255,245)',
    laserHalo:'rgb(30,255,170)',
    sparkCore:'rgb(220,255,240)' // base tone for spark sprite
  };

  // Layout
  const rect = {x:W*0.12, y:H*0.18, w:W*0.76, h:H*0.64};
  const bbox = inset(rect, rect.w*0.08, rect.h*0.12, rect.w*0.08, rect.h*0.16);
  const gantryY = rect.y - 60;

  // Background art and slab
  paintArt(artCtx);
  slabCtx.fillStyle = COL.slab; rr(slabCtx, rect.x, rect.y, rect.w, rect.h, 12); slabCtx.fill();

  // Gaussian + motion path (upper curve + baseline return)
  const upper = gaussianUpperPolyline(650, bbox);
  const upperPath = densify(upper, 2);
  const baseY = bbox.y + bbox.h;
  const basePts = [];
  for (let i=upperPath.length-1;i>=0;i--) basePts.push([upperPath[i][0], baseY]);
  const closed = upperPath.concat(densify(basePts,3));
  const N = closed.length;
  const U = upperPath.length;
  const centroid = polygonCentroid(closed);

  // Etch style
  etchCtx.lineCap='round'; etchCtx.lineJoin='round';
  etchCtx.shadowColor='rgba(60,255,180,0.8)'; etchCtx.shadowBlur=16;
  etchCtx.strokeStyle='rgba(210,255,235,0.95)'; etchCtx.lineWidth=3;

  // ---- SPARKS: BIG BOY EDITION ----
  const SP = {
    MAX_SPARKS: 3000,              // hard cap
    EMIT_RATE: 2200,               // sparks per second at power=1 (over cut area)
    SIZE: [1.1, 3.2],              // radius range
    TRAIL_SECS: 0.060,             // motion stretch length (seconds worth of velocity)
    GRAVITY: 980,                  // px/s^2
    DRAG: 0.995,                   // per-frame^dt drag
    LIFETIME: [0.6, 1.4],          // seconds
    SPEED_TAN: [240, 560],         // along tangent
    SPEED_NRM: [-260, 260],        // perpendicular jitter
    JITTER: [-40, 40],             // added random XY
    BOUNCE_E: 0.35,                // bounce energy on slab top edge
    SPARK_COLOR: 'rgb(160,255,210)', // additive tint
  };

  // Spark sprite (soft radial glow)
  const sparkSprite = makeSparkSprite();

  // Spark pool
  const sparks = new Array(SP.MAX_SPARKS);
  let sparkCount = 0;
  function newSpark(x,y,vx,vy,life,size){
    if (sparkCount >= SP.MAX_SPARKS) return;
    sparks[sparkCount++] = {x,y,vx,vy,life,size};
  }

  // ---- Animation state ----
  let last = performance.now();
  let progress = 0; // 0..1, wraps
  let pass = 0;
  let lastEtchIdx = null;
  let lastLaser = null;
  let running = true;

  hudUpdate();
  requestAnimationFrame(loop);

  function loop(now){
    if (!running) return;
    let dt = (now - last)/1000; last = now;
    if (dt > 0.1) dt = 0.1;

    glowCtx.clearRect(0,0,W,H);

    // Progress and pass wrap
    const prevProg = progress;
    progress += P.speed * dt;
    while (progress >= 1){
      progress -= 1;
      pass++;
      lastEtchIdx = null;
      lastLaser = null;
      hudUpdate();

      if (pass >= MAX_PASSES){
        running = false;
        passBig.textContent = 'DONE ✅';
        hud.textContent = `Completed ${MAX_PASSES} passes`;
        break;
      }
    }
    if (!running){
      // Draw final frame composition and stop
      composeFrame();
      return;
    }

    // Position along closed path
    const idxf = progress*(N-1);
    const i = Math.floor(idxf);
    const tt = idxf - i;
    const [x0,y0] = closed[i];
    const [x1,y1] = closed[(i+1)%N];
    let lx = x0 + (x1-x0)*tt;
    let ly = y0 + (y1-y0)*tt;

    // Laser "power" & beam width flicker
    const t = now*0.001;
    const power = clamp(P.powerFloor,1,
      0.9 + 0.35*(noise1d(t*11.7)*0.6 + noise1d(t*3.9)*0.4));
    const widthCore = 1.6 + 0.8*(noise1d(t*7.3)*0.5 + 0.5);

    // Tiny jitter for life
    lx += (noise1d(t*41.2)-0.5)*1.0;
    ly += (noise1d(t*37.9)-0.5)*1.0;

    // Cut slab + reveal wedge only when inside the slab
    if (inside(lx,ly,rect)){
      slabCtx.save();
      slabCtx.globalCompositeOperation='destination-out';
      const g = slabCtx.createRadialGradient(lx,ly,0,lx,ly,P.kerf+1.0);
      g.addColorStop(0,`rgba(0,0,0,${(0.30*power).toFixed(3)})`);
      g.addColorStop(1,'rgba(0,0,0,0)');
      slabCtx.fillStyle=g;
      slabCtx.beginPath(); slabCtx.arc(lx,ly,P.kerf,0,Math.PI*2); slabCtx.fill();

      // reveal wedge toward centroid (feather via opacity)
      const vx = centroid.x - lx, vy = centroid.y - ly;
      const m = Math.hypot(vx,vy)||1; const ux = vx/m, uy = vy/m;
      const nx = -uy, ny = ux;
      const L = P.revealLen * (0.7 + 0.6*power);
      const Wedge = P.revealWidth;
      slabCtx.beginPath();
      slabCtx.moveTo(lx, ly);
      slabCtx.lineTo(lx + ux*L + nx*Wedge*0.5, ly + uy*L + ny*Wedge*0.5);
      slabCtx.lineTo(lx + ux*L - nx*Wedge*0.5, ly + uy*L - ny*Wedge*0.5);
      slabCtx.closePath();
      slabCtx.fillStyle = `rgba(0,0,0,${(0.20*power).toFixed(3)})`;
      slabCtx.fill();
      slabCtx.restore();
    }

    // Laser beam (green)
    const gx = clamp(rect.x-60, rect.x+rect.w+60, lx);
    drawBeam(glowCtx, gx, gantryY, lx, ly, widthCore, power);

    // ======= MEGA SPARK EMISSION =======
    // Emit only when the head is over the Gaussian segment of the path (i < U-1)
    if (i < U-1) {
      // Tangent/normal directions at head
      const [tx,ty] = tangentAt(closed, i);
      const nx = -ty, ny = tx;

      // Number of sparks this frame (scaled by power)
      const want = SP.EMIT_RATE * power * dt;
      const emitCount = Math.min( Math.floor(want + Math.random()), SP.MAX_SPARKS - sparkCount );

      for (let s=0; s<emitCount; s++){
        // Velocities: strong tangent, some normal, a bit of jitter
        const vTan = rand(...SP.SPEED_TAN);
        const vNrm = rand(...SP.SPEED_NRM);
        const jx = rand(...SP.JITTER), jy = rand(...SP.JITTER);
        const vx = tx*vTan + nx*vNrm + jx;
        const vy = ty*vTan + ny*vNrm + jy;

        const life = rand(...SP.LIFETIME);
        const size = rand(...SP.SIZE);
        newSpark(lx, ly, vx, vy, life, size);
      }
    }

    // ======= SPARK UPDATE + RENDER =======
    renderSparks(glowCtx, dt);

    // ======= ETCH THE GAUSSIAN (solid line persists) =======
    const prev = lastLaser ?? { idx: i+tt, x: lx, y: ly };
    const fromIdx = prev.idx, toIdx = i+tt;
    const steps = 12;
    for (let s=1; s<=steps; s++){
      const k = lerp(fromIdx, toIdx, s/steps);
      const ki = Math.floor(clamp(0, N-2, k));
      const kt = k - ki;
      const [ax,ay] = closed[ki];
      const [bx,by] = closed[ki+1];
      const sx = ax + (bx-ax)*kt;
      const sy = ay + (by-ay)*kt;

      if (ki < U-1){
        etchCtx.beginPath();
        if (lastEtchIdx == null){
          etchCtx.moveTo(sx, sy);
        } else {
          if (ki < lastEtchIdx || ki - lastEtchIdx > 50){
            etchCtx.moveTo(sx, sy);
          } else {
            const [px,py] = upperPath[lastEtchIdx];
            etchCtx.moveTo(px, py);
          }
        }
        etchCtx.lineTo(sx, sy);
        etchCtx.stroke();
        lastEtchIdx = ki;
      } else {
        lastEtchIdx = null; // break continuity on baseline return
      }
    }
    lastLaser = { idx: i+tt, x: lx, y: ly };

    // Compose frame
    composeFrame();

    // next frame
    requestAnimationFrame(loop);
  }

  function composeFrame(){
    ctx.drawImage(art,0,0);
    ctx.drawImage(slab,0,0);
    ctx.globalCompositeOperation='screen';
    ctx.drawImage(etch,0,0);
    ctx.globalCompositeOperation='lighter';
    ctx.drawImage(glow,0,0);
    ctx.globalCompositeOperation='source-over';
    ctx.strokeStyle = COL.frame; ctx.lineWidth=1.2;
    rr(ctx, rect.x, rect.y, rect.w, rect.h, 12); ctx.stroke();
  }

  function hudUpdate(){
    hud.textContent = `Pass: ${Math.min(pass+1, MAX_PASSES)} / ${MAX_PASSES}`;
    passBig.textContent = pass < MAX_PASSES ? `PASS ${pass+1}` : 'DONE ✅';
  }

  // ====== Spark system ======
  function renderSparks(g, dt){
    // physics + cull + draw
    g.save();
    g.globalCompositeOperation = 'lighter';

    // Update
    const drag = Math.pow(SP.DRAG, dt*60);
    const top = rect.y; // bounce off slab top
    let write = 0;
    for (let idx=0; idx<sparkCount; idx++){
      const s = sparks[idx];

      // lifetime
      s.life -= dt;
      if (s.life <= 0) continue;

      // physics
      s.vx *= drag;
      s.vy = s.vy*drag + SP.GRAVITY*dt;

      // integrate
      s.x += s.vx*dt;
      s.y += s.vy*dt;

      // bounce off the slab top edge when falling onto it from above
      if (s.y >= top && s.y <= top + 2 && s.vy > 0 && s.x >= rect.x && s.x <= rect.x + rect.w) {
        s.y = top - 0.01;
        s.vy *= -SP.BOUNCE_E;
        s.vx *= 0.9;
      }

      // cull offscreen
      if (s.x < -200 || s.x > W+200 || s.y < -200 || s.y > H+300) continue;

      // draw trail as stretched sprite along velocity
      const speed = Math.hypot(s.vx, s.vy);
      const len = Math.max(8, speed * SP.TRAIL_SECS);
      const thick = Math.max(2, s.size*2.2);
      const ang = Math.atan2(s.vy, s.vx);

      g.translate(s.x, s.y);
      g.rotate(ang);
      g.globalAlpha = Math.max(0, Math.min(1, s.life));
      // soft outer + bright core
      g.drawImage(sparkSprite, -len*0.7, -thick*1.2, len*1.4, thick*2.4);
      g.globalAlpha = Math.max(0, Math.min(1, s.life*1.2));
      g.drawImage(sparkSprite, -len*0.5, -thick*0.6, len*1.0, thick*1.2);
      g.setTransform(1,0,0,1,0,0); // reset

      // keep
      sparks[write++] = s;
    }
    sparkCount = write;

    g.restore();
  }

  function makeSparkSprite(){
    const S = 96;
    const cv = document.createElement('canvas'); cv.width = cv.height = S;
    const c = cv.getContext('2d');
    const g = c.createRadialGradient(S/2,S/2,1, S/2,S/2,S/2);
    // core hot
    g.addColorStop(0.00, 'rgba(255,255,255,1.0)');
    g.addColorStop(0.15, 'rgba(230,255,245,0.95)');
    // greenish plasma
    g.addColorStop(0.40, 'rgba(120,255,200,0.55)');
    g.addColorStop(1.00, 'rgba(120,255,200,0.0)');
    c.fillStyle = g;
    c.beginPath(); c.arc(S/2,S/2,S/2,0,Math.PI*2); c.fill();
    return cv;
  }

  // ====== Laser beam ======
  function drawBeam(g,x0,y0,x1,y1,w,p){
    g.save(); g.globalCompositeOperation='lighter';
    g.strokeStyle=withAlpha(COL.laserHalo,0.35*p);
    g.lineWidth=w+6; g.lineCap='round';
    g.beginPath(); g.moveTo(x0,y0); g.lineTo(x1,y1); g.stroke();
    g.strokeStyle=withAlpha(COL.laserCore,Math.max(0.05,p));
    g.lineWidth=w;
    g.beginPath(); g.moveTo(x0,y0); g.lineTo(x1,y1); g.stroke();
    // tip bloom
    g.fillStyle=withAlpha(COL.laserHalo,0.65);
    for(let i=0;i<3;i++){ g.beginPath(); g.arc(x1,y1, 6+i*6, 0, Math.PI*2); g.fill(); }
    g.restore();
  }

  // ====== Art & geometry helpers ======
  function paintArt(g){
    const grad=g.createLinearGradient(0,0,W,H);
    grad.addColorStop(0,'#102b1e'); grad.addColorStop(1,'#3bd6a6');
    g.fillStyle=grad; g.fillRect(0,0,W,H);
    g.globalAlpha=0.18; g.strokeStyle='#fff';
    for(let x=0;x<=W;x+=40){g.beginPath();g.moveTo(x,0);g.lineTo(x,H);g.stroke();}
    for(let y=0;y<=H;y+=40){g.beginPath();g.moveTo(0,y);g.lineTo(W,y);g.stroke();}
    g.globalAlpha=1; g.fillStyle='rgba(235,255,245,0.95)';
    g.font='bold 46px Consolas,monospace'; g.textAlign='center'; g.textBaseline='middle';
    g.fillText('Bayesian Modeling & Inference',W/2,H*0.14);
  }

  function gaussianUpperPolyline(samples,box){
    const pts=[]; for(let i=0;i<samples;i++){
      const x=-3+6*(i/(samples-1)), y=Math.exp(-0.5*x*x);
      const sx=box.x+((x+3)/6)*box.w, sy=box.y+box.h - y*box.h;
      pts.push([sx,sy]);
    } return pts;
  }
  function densify(pts,step=2){
    const out=[]; for(let i=0;i<pts.length-1;i++){
      const [x0,y0]=pts[i],[x1,y1]=pts[i+1];
      const dx=x1-x0,dy=y1-y0,len=Math.hypot(dx,dy);
      const n=Math.max(1,Math.floor(len/step));
      for(let s=0;s<n;s++){const t=s/n; out.push([x0+dx*t,y0+dy*t]);}
    } out.push(pts.at(-1)); return out;
  }
  function polygonCentroid(pts){let sx=0,sy=0;for(const p of pts){sx+=p[0];sy+=p[1];}return{x:sx/pts.length,y:sy/pts.length};}
  function tangentAt(path,i){
    const i0=Math.max(0,i-1), i1=Math.min(path.length-1,i+1);
    const [x0,y0]=path[i0], [x1,y1]=path[i1];
    const dx=x1-x0, dy=y1-y0, m=Math.hypot(dx,dy)||1;
    return [dx/m, dy/m];
  }

  // ====== Utilities ======
  function mk(w,h){const c=document.createElement('canvas');c.width=w;c.height=h;return c;}
  function inset(r,l,t,ri,b){return{x:r.x+l,y:r.y+t,w:r.w-l-ri,h:r.h-t-b};}
  function rr(g,x,y,w,h,r){g.beginPath();g.moveTo(x+r,y);g.arcTo(x+w,y,x+w,y+h,r);
    g.arcTo(x+w,y+h,x,y+h,r);g.arcTo(x,y+h,x,y,r);g.arcTo(x,y,x+w,y,r);g.closePath();}
  function inside(x,y,r){return x>=r.x&&x<=r.x+r.w&&y>=r.y&&y<=r.y+r.h;}
  function rand(a,b){return a+Math.random()*(b-a);}
  function clamp(a,b,c){return Math.max(a,Math.min(b,c));}
  function lerp(a,b,t){return a+(b-a)*t;}
  function withAlpha(rgb,a){return rgb.replace('rgb(','rgba(').replace(')',','+a.toFixed(3)+')');}
  function noise1d(x){const i=Math.floor(x),f=x-i,u=f*f*(3-2*f);return lerp(hash(i),hash(i+1),u);}
  function hash(n){return fract(Math.sin(n*127.1)*43758.5453123);}
  function fract(x){return x-Math.floor(x);}
})();
</script>
</body>
</html>

