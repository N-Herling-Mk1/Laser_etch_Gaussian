<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Laser Etch — Multi-Laser Gaussian → Ember Text (Fewer but Stronger Cut Sparks + Solid Connectivity)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#000;
      --slab:#0c0d10;
      --frame:#13151a;
    }
    html,body{
      margin:0;
      height:100%;
      background:var(--bg);
      color:#e9fff5;
      font:14px/1.25 ui-monospace,Consolas,Menlo,monospace;
    }
    .wrap{
      display:grid;
      place-items:center;
      min-height:100%;
    }
    canvas{
      display:block;
      width:min(100vw,1280px);
      height:auto;
      max-height:92vh;
      border-radius:12px;
      box-shadow:0 18px 60px rgba(0,0,0,.55);
    }
    .hud{
      position:fixed;
      left:50%;
      top:10px;
      transform:translateX(-50%);
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.08);
      padding:6px 10px;
      border-radius:8px;
      color:#bfffe9;
      font:13px Consolas,monospace;
      pointer-events:none;
      user-select:none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c" width="1280" height="720"></canvas>
  </div>
  <div class="hud" id="hud">Phase 1/5 — Gaussian (multi-laser)</div>

  <script>
  (() => {
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    const W = canvas.width, H = canvas.height;
    const hud = document.getElementById("hud");

    /* ================= Layers ================= */
    const bg     = mk(W,H), bgCtx     = bg.getContext("2d");
    const slab   = mk(W,H), slabCtx   = slab.getContext("2d");
    const curve  = mk(W,H), curveCtx  = curve.getContext("2d");          // glow stroke
    const curveSolid = mk(W,H), curveSolidCtx = curveSolid.getContext("2d"); // solid under-stroke
    const border = mk(W,H), borderCtx = border.getContext("2d");          // glow stroke
    const borderSolid = mk(W,H), borderSolidCtx = borderSolid.getContext("2d"); // solid under-stroke
    const glow   = mk(W,H), glowCtx   = glow.getContext("2d");
    const live   = mk(W,H), liveCtx   = live.getContext("2d");
    const embers = mk(W,H), embCtx    = embers.getContext("2d");
    const reveal = mk(W,H), revealCtx = reveal.getContext("2d");
    const letterGlow = mk(W,H), glowTextCtx = letterGlow.getContext("2d");
    const textMask = mk(W,H), textMaskCtx = textMask.getContext("2d");
    const textBlock = mk(W,H), textBlockCtx = textBlock.getContext("2d");  // geometry only

    /* ================= Background ================= */
    bgCtx.fillStyle = "#000";
    bgCtx.fillRect(0,0,W,H);

    /* ================= Layout ================= */
    const rect = { x:Math.floor(W*0.12), y:Math.floor(H*0.18), w:Math.floor(W*0.76), h:Math.floor(H*0.64) };
    const bbox = inset(rect, Math.floor(rect.w*0.08), Math.floor(rect.h*0.12), Math.floor(rect.w*0.08), Math.floor(rect.h*0.16));
    const baseY = bbox.y + bbox.h;

    /* ================= Slab ================= */
    slabCtx.fillStyle = "#0c0d10";
    rr(slabCtx, rect.x, rect.y, rect.w, rect.h, 12);
    slabCtx.fill();

    /* ================= Gaussian Paths (even denser + solid under-stroke) ================= */
    const upper = gaussianUpperPolyline(1000, bbox);      // more samples (800→1000)
    const upperPath = densify(upper, 0.9);                // denser (1.25→0.9)
    const basePts = [];
    for (let i=upperPath.length-1; i>=0; i--) basePts.push([upperPath[i][0], baseY]);
    const baseline = densify(basePts, 0.9);
    const closed = upperPath.concat(baseline);
    const U = upperPath.length;
    const N = closed.length;
    const centroid = polygonCentroid(closed);

    /* ================= Park Location ================= */
    const parkPoint = { x: upperPath[0][0], y: baseY };
    const parkVerticalOrigin = { x: parkPoint.x, y: rect.y - 120 };

    /* ================= Styles ================= */
    // Glow strokes
    curveCtx.lineCap="round";  curveCtx.lineJoin="round";  curveCtx.miterLimit = 2;
    curveCtx.strokeStyle="rgba(140,255,210,1)";
    curveCtx.shadowColor="rgba(60,255,180,0.9)";
    curveCtx.shadowBlur=16;
    curveCtx.lineWidth=3.6;  // thicker (3→3.6)

    borderCtx.lineCap = "round"; borderCtx.lineJoin = "round"; borderCtx.miterLimit = 2;
    borderCtx.strokeStyle = "rgba(140,255,210,1)";
    borderCtx.shadowColor = "rgba(60,255,180,0.9)";
    borderCtx.shadowBlur = 14;
    borderCtx.lineWidth = 3.0;  // thicker (2.4→3.0)

    // Solid under-strokes (quiet mint)
    curveSolidCtx.lineCap="round"; curveSolidCtx.lineJoin="round";
    curveSolidCtx.strokeStyle="rgba(120,230,200,0.9)";
    curveSolidCtx.lineWidth=1.3;

    borderSolidCtx.lineCap="round"; borderSolidCtx.lineJoin="round";
    borderSolidCtx.strokeStyle="rgba(120,230,200,0.9)";
    borderSolidCtx.lineWidth=1.3;

    /* ================= Text Mask ================= */
    const L1 = "INFO 510";
    const L2 = "Bayesian Modelling and Inference";
    const fontL1 = "bold 50px Consolas,ui-monospace,monospace";
    const fontL2 = "bold 46px Consolas,ui-monospace,monospace";

    textMaskCtx.textAlign="center";
    textMaskCtx.textBaseline="middle";
    const tx = rect.x + rect.w/2;
    const raiseFactor = 0.16;
    const tyRaise = Math.round(bbox.h*raiseFactor);
    const tyCenter = Math.round(clamp(bbox.y+60, bbox.y+bbox.h-60, (bbox.y + bbox.h/2) - tyRaise));
    const lineGap = 56;
    const y1 = tyCenter - lineGap/2;
    const y2 = tyCenter + lineGap/2;

    textMaskCtx.fillStyle="#fff";
    textMaskCtx.shadowColor="rgba(60,255,180,0.8)";
    textMaskCtx.shadowBlur=6;
    textMaskCtx.font=fontL1;
    const tw1 = textMaskCtx.measureText(L1).width;
    textMaskCtx.fillText(L1, tx, y1);
    textMaskCtx.font=fontL2;
    const tw2 = textMaskCtx.measureText(L2).width;
    textMaskCtx.fillText(L2, tx, y2);
    const textAlphaData = textMaskCtx.getImageData(0,0,W,H).data;

    const textW = Math.max(tw1, tw2);
    const padX = 90, padY = 52;
    const textRect = {
      x: tx - textW/2 - padX,
      y: y1 - padY,
      w: textW + 2*padX,
      h: (y2 - y1) + 2*padY
    };

    // geometry only (not drawn)
    textBlockCtx.fillStyle = "#020403";
    textBlockCtx.globalAlpha = 0.97;
    rr(textBlockCtx, textRect.x, textRect.y, textRect.w, textRect.h, 14);
    textBlockCtx.fill();
    textBlockCtx.globalAlpha = 1;

    const boxEdgePath = buildRectPath(textRect, 0.9);   // denser (1.25→0.9)

    /* ================= Multi-Lasers ================= */
    const multiLasers = [
      { x: W*0.5,                y: rect.y - 90,  power:1.0, width:1.0,  phase:0.0 },
      { x: rect.x - 90,          y: rect.y - 40,  power:0.9, width:0.95, phase:0.4 },
      { x: rect.x + rect.w + 90, y: rect.y - 50,  power:0.9, width:0.9,  phase:1.1 },
      { x: rect.x - 120,         y: rect.y + rect.h*0.35, power:0.8, width:0.85, phase:1.8 }
    ];

    /* ================= Sparks (global base) ================= */
    // Keep base behavior for Gaussian/box; we'll override for cut-text phases.
    const SP = {
      MAX: 2400,
      EMIT: 1700,
      GRAV: 980,
      DRAG: 0.995,
      LIFE: [0.5,1.0],
      VT: [240,520],
      VN: [-160,160],
      JIT: [-26,26],
      BOUNCE: 0.35
    };
    const sparkSprite = makeSparkSprite();
    const sparks = new Array(SP.MAX);
    let sparkCount=0;

    /* ================= Cut-text spark modifiers (fewer but stronger) ================= */
    const CUT = {
      EMIT_SCALE: 0.35,    // fewer sparks (35% of normal)
      STREAK_GAIN: 1.25,   // longer streak render
      CORE_GAIN: 1.35,     // brighter core render
      SIZE_GAIN: 1.25      // slightly thicker
    };

    /* ================= Letter-Spark Tunables (quick bright pop) ================= */
    const LETTER_SPARK = {
      RATE: 80,                 // fewer letter sparks (110→80)
      SPEED: [140, 300],
      LIFE: [0.45, 0.7],        // quick pop/fade
      SIZE: [1.2, 2.2],
      ANGLE_BIAS: [-1.6, 1.6],
      JITTER: 0.55
    };
    const letterSparkPhase = Math.random()*Math.PI*2;

    /* ================= Embers ================= */
    const EMB = {
      MAX: 3800,
      SPAWN_RATE: 2400,
      LIFE: [0.65, 1.6],
      SPEED: [-16, -6],
      JX: [-18,18],
      GRAV: -9,
      SIZE: [1.35, 3.8],
      GROW: [0.7, 1.5],
      ORANGE: [255, 190, 110],
      MINT:   [140, 255, 210],
      TAIL_RATE: 460,
      BASE_FLAME_RATE: 660,
      POP_RATE: 0.24
    };
    const embList = new Array(EMB.MAX);
    let embCount = 0;

    /* ================= State & Timing ================= */
    const PHASE = { GAUSS:0, BOX_EDGE:1, BOX_LETTER_ENTRY:2, BOX_JITTER:3, REVEAL:4 };
    let phase = PHASE.GAUSS;

    let last = performance.now();
    let progGaussian = 0;
    let progBoxEdge  = 0;

    // Accumulator for solid-understroke connectivity
    let curvePrev = null;
    let borderPrev = null;

    // letter entry: random side anchors
    const sideAnchors = makeSideAnchors(textRect, 9);
    let entryTimer = 0, entryPoint = null, entryTarget = null;
    const ENTRY_HOP = 0.32;
    const ENTRY_TWEEN = 0.18;

    let jitterStart = 0;
    let jitterTarget = null;
    const JITTER_DUR = 2.1;

    // Reveal + post-zaps timing
    let revealStart = 0;
    const TEXT_REVEAL_DUR = 1.2;
    const POST_ZAP_DELAY  = 0.10;
    const POST_ZAP_DUR    = 3.0;
    const ZAP_RATE        = 22;

    const GLOW_FLOOR  = 0.16;

    hudUpdate();
    requestAnimationFrame(loop);

    function loop(now){
      const dt = Math.min((now - last)/1000, 0.1);
      last = now;
      const nowSec = now/1000;

      glowCtx.clearRect(0,0,W,H);
      liveCtx.clearRect(0,0,W,H);
      embCtx.clearRect(0,0,W,H);
      revealCtx.clearRect(0,0,W,H);
      glowTextCtx.clearRect(0,0,W,H);

      const t = now*0.001;
      const basePower = clamp(0.35,1, 0.9 + 0.4*(noise1d(t*11.7)*0.6 + noise1d(t*3.9)*0.4));
      const baseWidth = 1.4 + 0.7*(noise1d(t*7.3)*0.5 + 0.5);

      if (phase === PHASE.GAUSS){
        progGaussian += 0.42*dt;
        if (progGaussian >= 1){
          progGaussian = 1;
          phase = PHASE.BOX_EDGE;
          hudUpdate();
        }

        const {i,tt,x0,y0,x1,y1} = segAt(closed, progGaussian);
        const lx = x0 + (x1-x0)*tt;
        const ly = y0 + (y1-y0)*tt;
        const [txv,tyv] = tangentAt(closed, i);

        // beams
        for (const src of multiLasers){
          const pulse = 0.6 + 0.4*Math.sin( (t*3.2) + src.phase*2.0 + Math.random()*0.4 );
          const p = clamp(0.25,1, basePower * (src.power || 1) * pulse);
          const w = baseWidth * (src.width || 1);
          drawBeam(glowCtx, src.x, src.y, lx, ly, w, p, 0.0);
        }

        // sparks + carving
        emitSparks(lx,ly,txv,tyv,basePower,1.0,dt,false);
        if (inside(lx,ly,rect)) carveSlabPointAndWedge(slabCtx, lx, ly, centroid, basePower);

        // CONNECTED drawing: solid under-stroke + glow stroke
        traceSolid(curveSolidCtx, closed, i, tt, true);
        traceGlow(curveCtx, closed, i, tt, true);

        drawLiveHit(liveCtx, lx, ly, 16);
      }
      else if (phase === PHASE.BOX_EDGE){
        progBoxEdge += 0.6*dt;
        if (progBoxEdge >= 1){
          progBoxEdge = 1;
          phase = PHASE.BOX_LETTER_ENTRY;
          entryTimer = 0;
          hudUpdate();
        }

        const {i,tt,x0,y0,x1,y1} = segAt(boxEdgePath, progBoxEdge);
        const lx = x0 + (x1-x0)*tt;
        const ly = y0 + (y1-y0)*tt;
        const [txv,tyv] = tangentAt(boxEdgePath, i);

        for (const src of multiLasers){
          const pulse = 0.55 + 0.45*Math.sin( (t*3.6) + src.phase*1.6 );
          const p = clamp(0.25,1, basePower * (src.power || 1) * pulse);
          const w = baseWidth * (src.width || 1);
          drawBeam(glowCtx, src.x, src.y, lx, ly, w, p, 0.0);
        }

        emitSparks(lx,ly,txv,tyv,basePower,0.85,dt,false);
        drawLiveHit(liveCtx, lx, ly, 13);
        carveSlabStroke(slabCtx, x0, y0, lx, ly, 6);

        traceSolid(borderSolidCtx, boxEdgePath, i, tt, false);
        traceGlow(borderCtx,        boxEdgePath, i, tt, false);
      }
      else if (phase === PHASE.BOX_LETTER_ENTRY){
        // Random side entry → quick tween inside
        entryTimer += dt;
        if (!entryPoint || entryTimer >= ENTRY_HOP){
          entryTimer = 0;
          entryPoint  = randomSideAnchor(sideAnchors);
          entryTarget = randomPointInRect(textRect);
        }
        const k = clamp(0,1, entryTimer / ENTRY_TWEEN);
        const lx = lerp(entryPoint.x, entryTarget.x, k);
        const ly = lerp(entryPoint.y, entryTarget.y, k);

        for (const src of multiLasers){
          const pulse = 0.62 + 0.38*Math.sin( (t*4.0) + src.phase*2.1 );
          const p = clamp(0.25,1, basePower * (src.power || 1) * pulse);
          const w = baseWidth * (src.width || 1);
          drawBeam(glowCtx, src.x, src.y, lx, ly, w, p, 0.0);
        }

        // >>> CUT TEXT SPARKS: fewer but stronger <<<
        emitSparks(lx,ly,0,-1,basePower, CUT.EMIT_SCALE, dt, true);
        drawLiveHit(liveCtx, lx, ly, 11);
        carveSlabPointAndWedge(slabCtx, lx, ly, {x:lx,y:ly}, basePower*0.55, 5);

        // stochastic transition
        if (Math.random() < 0.015){
          phase = PHASE.BOX_JITTER;
          jitterStart = nowSec;
          jitterTarget = randomPointInRect(textRect);
          hudUpdate();
        }
      }
      else if (phase === PHASE.BOX_JITTER){
        const elapsed = nowSec - jitterStart;
        if (!jitterTarget || Math.random() < 0.2){
          jitterTarget = randomPointInRect(textRect);
        }
        const lx = jitterTarget.x;
        const ly = jitterTarget.y;

        for (const src of multiLasers){
          const pulse = 0.6 + 0.4*Math.sin( (t*4.1) + src.phase*2.3 );
          const p = clamp(0.25,1, basePower * (src.power || 1) * pulse);
          const w = baseWidth * (src.width || 1);
          drawBeam(glowCtx, src.x, src.y, lx, ly, w, p, 0.0);
        }

        // >>> CUT TEXT SPARKS: fewer but stronger <<<
        emitSparks(lx,ly,0,-1,basePower, CUT.EMIT_SCALE, dt, true);
        drawLiveHit(liveCtx, lx, ly, 10);
        carveSlabPointAndWedge(slabCtx, lx, ly, {x:lx,y:ly}, basePower*0.45, 4);

        if (elapsed >=  JITTER_DUR){
          phase = PHASE.REVEAL;
          revealStart = nowSec + 0.45;
          hudUpdate();
        }
      }
      else {
        // Merge beams to parked tip
        const tmerge = clamp(0,1, (nowSec - revealStart + 0.25)/0.6 );
        for (const src of multiLasers){
          const ox = lerp(src.x, parkVerticalOrigin.x, tmerge);
          const oy = lerp(src.y, parkVerticalOrigin.y, tmerge);
          const pulse = 0.6 + 0.4*Math.sin(nowSec*9 + src.phase);
          const p = clamp(0.3,1, 0.7*pulse);
          drawBeam(glowCtx, ox, oy, parkPoint.x, parkPoint.y, 1.6, p, 0.75, 0.55);
        }

        emitSparksRadial(parkPoint.x, parkPoint.y, 0.25, dt, 160);

        // Reveal + embers + letter sparks
        const el = nowSec - revealStart;
        if (el > 0){
          const fade   = clamp(0,1, el / TEXT_REVEAL_DUR);
          const ignite = easeOutCubic(fade);
          const pulse  = 0.85 + 0.15*Math.sin(nowSec*8.0);
          const emberVis = Math.max(0.32, Math.pow(1 - fade, 1.10));

          if (Math.random() < 0.24 * dt * 60){
            letterPopBurst(textRect, textAlphaData, randInt(2,5));
          }

          const spawnGain = Math.max(0, (1.0 - fade) - 0.2);
          updateEmbers(dt, spawnGain * emberVis, textRect, textAlphaData);

          const zapWindowStart = TEXT_REVEAL_DUR + POST_ZAP_DELAY;
          const zapWindowEnd   = zapWindowStart + POST_ZAP_DUR;
          if (el > zapWindowStart && el < zapWindowEnd){
            const zapsThisFrame = Math.floor(ZAP_RATE * (dt + Math.random()*0.02));
            for (let z=0; z<zapsThisFrame; z++){
              const target = pickRandomTextPoint(textRect, textAlphaData, 15);
              if (!target) continue;
              const src = multiLasers[(z + Math.floor(nowSec*37)) % multiLasers.length];
              const p = 0.6 + 0.4*Math.sin(nowSec*20 + z*1.7);
              drawBeam(glowCtx, src.x, src.y, target.x, target.y, 1.2, p, 0.35);
              drawLiveHit(liveCtx, target.x, target.y, 10);
              carveSlabPointAndWedge(slabCtx, target.x, target.y, target, 0.35, 3.5);
              emitSparksRadial(target.x, target.y, 0.5, dt * 0.65, 140);
              updateEmbers(dt, 0.38, textRect, textAlphaData);
            }
          }

          // base/tail flame
          const baseGain = EMB.BASE_FLAME_RATE / EMB.SPAWN_RATE;
          updateEmbers(dt, baseGain, textRect, textAlphaData);
          if (el > zapWindowEnd){
            const tailGain = (EMB.TAIL_RATE / EMB.SPAWN_RATE);
            updateEmbers(dt, tailGain, textRect, textAlphaData);
          }

          // occasional letter-origin sparks
          const mod = 0.6 + 0.4*Math.sin(nowSec*1.7 + letterSparkPhase);
          emitLetterSparksFromText(LETTER_SPARK.RATE * mod, dt, textRect, textAlphaData);

          renderEmbers(embCtx, ignite, Math.min(1, emberVis * 1.15));

          // heat bloom → mint
          const bloom = mk(W,H), bctx = bloom.getContext('2d');
          bctx.drawImage(textMask,0,0);
          bctx.globalCompositeOperation='source-in';
          const [r0,g0,b0] = [255,190,110], [r1,g1,b1] = [140,255,210];
          const rr = Math.round(lerp(r0,r1, ignite*0.6));
          const gg = Math.round(lerp(g0,g1, ignite*0.6));
          const bb = Math.round(lerp(b0,b1, ignite*0.6));
          bctx.fillStyle = `rgba(${rr},${gg},${bb},${(0.38*pulse*emberVis).toFixed(3)})`;
          bctx.shadowColor = `rgba(${rr},${gg},${bb},${(0.95*emberVis).toFixed(3)})`;
          bctx.shadowBlur = (20 + 20*ignite) * (0.65 + 0.35*emberVis);
          bctx.fillRect(0,0,W,H);
          revealCtx.globalCompositeOperation='lighter';
          revealCtx.drawImage(bloom,0,0);

          const mint = mk(W,H), mctx = mint.getContext('2d');
          mctx.drawImage(textMask,0,0);
          mctx.globalCompositeOperation='source-in';
          mctx.fillStyle = "rgba(140,255,210,1)";
          mctx.fillRect(0,0,W,H);
          revealCtx.globalAlpha = ignite * 0.98;
          revealCtx.globalCompositeOperation='screen';
          revealCtx.drawImage(mint,0,0);
          revealCtx.globalAlpha = 1;

          // persistent mint halo
          glowTextCtx.save();
          glowTextCtx.drawImage(textMask,0,0);
          glowTextCtx.globalCompositeOperation = 'source-in';
          const floorPulse = 0.75 + 0.25*Math.sin(nowSec*3.2);
          const floorAlpha = GLOW_FLOOR * (1.0 + 0.2*floorPulse);
          glowTextCtx.fillStyle = `rgba(140,255,210,${floorAlpha.toFixed(3)})`;
          glowTextCtx.shadowColor = `rgba(140,255,210,${(1.0*GLOW_FLOOR).toFixed(3)})`;
          glowTextCtx.shadowBlur = 18;
          glowTextCtx.fillRect(0,0,W,H);
          glowTextCtx.restore();
        }
      }

      composeFrame();
      requestAnimationFrame(loop);
    }

    /* ================= Compose ================= */
    function composeFrame(){
      ctx.globalCompositeOperation='source-over';
      ctx.drawImage(bg,0,0);
      ctx.drawImage(slab,0,0);

      // Solid under-strokes first (fills micro gaps), then glow strokes
      ctx.globalCompositeOperation='source-over';
      ctx.drawImage(curveSolid,0,0);
      ctx.drawImage(borderSolid,0,0);

      ctx.globalCompositeOperation='screen';
      ctx.drawImage(curve,0,0);
      ctx.drawImage(border,0,0);

      // Live hits, beams/sparks, embers, reveal bloom/text, and persistent letter glow
      ctx.globalCompositeOperation='lighter';
      ctx.drawImage(live,0,0);
      ctx.drawImage(glow,0,0);
      ctx.drawImage(embers,0,0);
      ctx.drawImage(reveal,0,0);
      ctx.drawImage(letterGlow,0,0);

      // Frame
      ctx.globalCompositeOperation='source-over';
      ctx.strokeStyle = "#13151a";
      ctx.lineWidth = 1.2;
      rr(ctx, rect.x, rect.y, rect.w, rect.h, 12);
      ctx.stroke();
    }

    function hudUpdate(){
      hud.textContent =
        (phase===0) ? "Phase 1/5 — Gaussian (multi-laser)"
      : (phase===1) ? "Phase 2/5 — Text box edge (carving neon border)"
      : (phase===2) ? "Phase 3/5 — Letter cuts: random side entry (fewer/stronger sparks)"
      : (phase===3) ? "Phase 4/5 — Jitter cuts in box (fewer/stronger sparks)"
      : "Phase 5/5 — Ember mint text + constant flame + subtle tip flare + letter sparks";
    }

    /* ================= Carving & Drawing ================= */
    function carveSlabPointAndWedge(g,lx,ly,centroid,power,kerf=6){
      g.save();
      g.globalCompositeOperation='destination-out';
      const rad = kerf + 1.5;
      const gr = g.createRadialGradient(lx,ly,0,lx,ly,rad);
      gr.addColorStop(0,`rgba(0,0,0,${(0.44*power).toFixed(3)})`);
      gr.addColorStop(1,'rgba(0,0,0,0)');
      g.fillStyle=gr;
      g.beginPath(); g.arc(lx,ly,kerf,0,Math.PI*2); g.fill();

      // small reveal wedge
      const vx = centroid.x - lx, vy = centroid.y - ly;
      const m = Math.hypot(vx,vy)||1;
      const ux = vx/m, uy = vy/m;
      const wx = -uy, wy = ux;
      const L = 34*(0.6+0.4*power);
      const Wd = 16;
      g.beginPath();
      g.moveTo(lx,ly);
      g.lineTo(lx+ux*L+wx*(Wd*0.5), ly+uy*L+wy*(Wd*0.5));
      g.lineTo(lx+ux*L-wx*(Wd*0.5), ly+uy*L-wy*(Wd*0.5));
      g.closePath();
      g.fillStyle=`rgba(0,0,0,${(0.24*power).toFixed(3)})`;
      g.fill();
      g.restore();
    }

    function carveSlabStroke(g, x0, y0, x1, y1, widthPx){
      g.save();
      g.globalCompositeOperation = 'destination-out';
      g.lineCap = 'round';
      g.lineJoin = 'round';
      g.miterLimit = 2;
      g.strokeStyle = 'rgba(0,0,0,1)';
      g.lineWidth = widthPx;
      g.beginPath();
      g.moveTo(x0,y0);
      g.lineTo(x1,y1);
      g.stroke();
      g.restore();
    }

    // Solid under-stroke tracer (strong connectivity)
    function traceSolid(g, path, i, tt, isCurve){
      const [x0,y0] = path[i];
      const [x1,y1] = path[i+1] ?? path[i];
      const x = x0 + (x1-x0)*tt;
      const y = y0 + (y1-y0)*tt;
      const prev = isCurve ? curvePrev : borderPrev;

      g.beginPath();
      if (prev){ g.moveTo(prev.x, prev.y); }
      else     { g.moveTo(x, y); }
      g.lineTo(x, y);
      g.stroke();

      if (isCurve) curvePrev = {x,y}; else borderPrev = {x,y};
    }

    // Glow tracer layered on top
    function traceGlow(g, path, i, tt){
      const STEPS = 10;
      const idxf = i + tt;
      for (let s=0;s<=STEPS;s++){
        const k = clamp(0, path.length-1-1e-4, idxf - (STEPS-s)*0.25);
        const ki = Math.floor(k);
        const kt = k - ki;
        const [ax,ay] = path[ki];
        const [bx,by] = path[ki+1] ?? path[ki];
        const sx = ax + (bx-ax)*kt;
        const sy = ay + (by-ay)*kt;
        g.beginPath();
        g.moveTo(ax,ay);
        g.lineTo(sx,sy);
        g.stroke();
      }
    }

    /* ========= Beam with controllable tip flare spread + glare scale ========= */
    function drawBeam(g,x0,y0,x1,y1,w,p,spread=0,glareScale=1){
      g.save();
      g.globalCompositeOperation='lighter';

      // shaft halo
      g.strokeStyle = `rgba(30,255,170,${(0.38*p).toFixed(3)})`;
      g.lineWidth = w+6;
      g.lineCap='round';
      g.beginPath(); g.moveTo(x0,y0); g.lineTo(x1,y1); g.stroke();

      // shaft core
      g.strokeStyle = `rgba(230,255,245,${(Math.max(0.06,p*0.95)).toFixed(3)})`;
      g.lineWidth = w;
      g.beginPath(); g.moveTo(x0,y0); g.lineTo(x1,y1); g.stroke();

      // tip bloom
      const flareR = glareScale * (7 + spread*18);
      const flareA = glareScale * (0.26 + 0.14*spread);
      g.fillStyle = `rgba(30,255,170,${(flareA).toFixed(3)})`;
      for (let i=0;i<2;i++){
        g.beginPath(); g.arc(x1,y1, flareR + i*4, 0, Math.PI*2); g.fill();
      }
      // tiny core pop
      g.fillStyle = `rgba(255,255,255,${(0.14*glareScale + 0.08*spread).toFixed(3)})`;
      g.beginPath(); g.arc(x1,y1, 2.0 + spread*0.7, 0, Math.PI*2); g.fill();

      // starburst spokes
      if (spread > 0){
        const spokes = Math.floor(6 + spread*8);
        for (let k=0;k<spokes;k++){
          const ang = (k/spokes)*Math.PI*2 + (Math.random()*0.12);
          const len = (10 + spread*22) * (0.55 + Math.random()*0.6) * (0.85*glareScale + 0.15);
          const th  = (1.1 + spread*0.7) * (0.8*glareScale + 0.2);
          g.translate(x1,y1);
          g.rotate(ang);
          g.globalAlpha = (0.18 + 0.14*Math.random()) * (0.8*glareScale + 0.2);
          g.fillRect(0, -th*0.5, len, th);
          g.setTransform(1,0,0,1,0,0);
        }
      }
      g.restore();
    }

    /* ================= Radial Sparks (with cap) ================= */
    function emitSparksRadial(cx,cy,intensity,dt,cap=Infinity){
      const want = SP.EMIT * intensity * dt;
      let count = Math.floor(want + Math.random());
      if (!isFinite(cap)) cap = Number.POSITIVE_INFINITY;
      count = Math.min(count, SP.MAX - sparkCount, cap);
      for (let i=0;i<count;i++){
        const ang = Math.random()*Math.PI*2;
        const spd = rand(180, 420);
        const vx  = Math.cos(ang) * spd + rand(-40,40);
        const vy  = Math.sin(ang) * spd + rand(-40,40);
        const life= rand(SP.LIFE[0], SP.LIFE[1]);
        const size= rand(1.1,2.7);
        newSpark(cx,cy,vx,vy,life,size);
      }
      renderSparks(glowCtx, dt, false);
    }

    /* ================= Letter Sparks ================= */
    function emitLetterSparksFromText(ratePerSec, dt, r, alphaData){
      const want = ratePerSec * dt;
      const count = Math.min(Math.floor(want + Math.random()), SP.MAX - sparkCount);
      for (let i=0; i<count; i++){
        const pt = pickRandomTextPoint(r, alphaData, 18);
        if (!pt) break;

        const baseAng = rand(LETTER_SPARK.ANGLE_BIAS[0], LETTER_SPARK.ANGLE_BIAS[1]);
        const jitter  = (Math.random()-0.5) * LETTER_SPARK.JITTER;
        const ang = baseAng + jitter;

        const spd = rand(LETTER_SPARK.SPEED[0], LETTER_SPARK.SPEED[1]);
        const vx = Math.cos(ang) * spd;
        const vy = Math.sin(ang) * spd;

        const life = rand(LETTER_SPARK.LIFE[0], LETTER_SPARK.LIFE[1]);
        const size = rand(LETTER_SPARK.SIZE[0], LETTER_SPARK.SIZE[1]);

        newSpark(pt.x, pt.y, vx, vy, life, size);
        drawLiveHit(liveCtx, pt.x, pt.y, 9);
      }
      // draw in renderSparks()
    }

    /* ================= Random micro pop burst ================= */
    function letterPopBurst(r, alphaData, n){
      for (let i=0;i<n;i++){
        const pt = pickRandomTextPoint(r, alphaData, 20);
        if (!pt) continue;
        const ang = Math.random()*Math.PI*2;
        const spd = rand(240, 520);
        const vx = Math.cos(ang)*spd, vy = Math.sin(ang)*spd;
        newSpark(pt.x, pt.y, vx, vy, rand(0.35,0.6), rand(1.4,2.4));
        drawLiveHit(liveCtx, pt.x, pt.y, 10);
      }
    }

    /* ================= Embers ================= */
    function updateEmbers(dt, gain, r, alphaData){
      if (gain <= 0) return;

      const want = 2400 * gain * dt;
      const count = Math.min(Math.floor(want + Math.random()), 3800 - embCount);
      for (let i=0;i<count;i++){
        const pt = pickRandomTextPoint(r, alphaData, 20);
        if (!pt) continue;
        const life = rand(0.65, 1.6);
        const vy = rand(-16, -6);
        const vx = rand(-18,18);
        const size = rand(1.35, 3.8);
        const grow = rand(0.7, 1.5);

        if (embCount >= 3800) break;
        embList[embCount++] = { x:pt.x, y:pt.y, vx, vy, t:0, life, size, grow };
      }

      // integrate
      let write=0;
      for (let i=0;i<embCount;i++){
        const e = embList[i];
        e.t += dt;
        if (e.t >= e.life) continue;

        // buoyancy + micro noise
        e.vy += -9 * dt;
        e.vx += (noise1d((e.x+e.t)*0.03)-0.5) * 8 * dt;
        e.vy += (noise1d((e.y-e.t)*0.03)-0.5) * 6 * dt;

        e.x += e.vx * dt;
        e.y += e.vy * dt;

        if (e.x < -40 || e.x > W+40 || e.y < -40 || e.y > H+80) continue;
        embList[write++] = e;
      }
      embCount = write;
    }

    function renderEmbers(g, ignite, strength){
      g.save();
      g.globalCompositeOperation='lighter';
      g.globalAlpha = clamp(0,1, strength);

      for (let i=0;i<embCount;i++){
        const e = embList[i];
        const k = clamp(0,1, e.t / e.life);
        const heat = Math.sin(Math.PI * Math.min(1, k));
        const sz = e.size * (1 + e.grow * heat * 0.65);

        const blend = clamp(0,1, 0.28 + 0.58*ignite + 0.35*k);
        const r = Math.round(lerp(255, 140, blend));
        const gg= Math.round(lerp(190, 255, blend));
        const b = Math.round(lerp(110, 210, blend));

        const aCore  = (0.24 + 0.64*(1-k) + 0.30*heat) * strength;
        const aHalo  = (0.12 + 0.54*(1-k)) * strength;

        const rad = sz*3.6 * (0.75 + 0.25*strength);

        const gr = g.createRadialGradient(e.x,e.y,0, e.x,e.y,rad);
        gr.addColorStop(0,   `rgba(${r},${gg},${b},${aCore.toFixed(3)})`);
        gr.addColorStop(0.4, `rgba(${r},${gg},${b},${aHalo.toFixed(3)})`);
        gr.addColorStop(1,   `rgba(${r},${gg},${b},0)`);
        g.fillStyle = gr;
        g.beginPath(); g.arc(e.x, e.y, rad, 0, Math.PI*2); g.fill();

        // bright core
        g.fillStyle = `rgba(${r},${gg},${b},${aCore.toFixed(3)})`;
        g.beginPath(); g.arc(e.x, e.y, sz*0.7, 0, Math.PI*2); g.fill();
      }
      g.restore();
    }

    /* ================= Standard Sparks ================= */
    // If "cutMode" is true → render fewer but stronger (CUT modifiers).
    function emitSparks(lx,ly,tx,ty,power,emit,dt,cutMode=false){
      const nx = -ty, ny = tx;
      let want = SP.EMIT * power * emit * dt;
      if (cutMode) want *= CUT.EMIT_SCALE; // fewer
      const count = Math.min(Math.floor(want + Math.random()), SP.MAX - sparkCount);
      for (let i=0;i<count;i++){
        const vT = rand(SP.VT[0], SP.VT[1]);
        const vN = rand(SP.VN[0], SP.VN[1]);
        const jx = rand(-18, 18);
        const jy = rand(-18, 18);
        const vx = tx*vT + nx*vN + jx;
        const vy = ty*vT + ny*vN + jy;
        const life = rand(SP.LIFE[0], SP.LIFE[1]);
        const size = rand(1.1* (cutMode?CUT.SIZE_GAIN:1), 2.2* (cutMode?CUT.SIZE_GAIN:1));
        newSpark(lx,ly,vx,vy,life,size, cutMode);
      }
      renderSparks(glowCtx, dt, cutMode);
    }

    function renderSparks(g,dt,cutMode){
      g.save();
      g.globalCompositeOperation='lighter';
      const drag = Math.pow(SP.DRAG, dt*60);
      const top = rect.y;
      let write=0;
      for (let i=0;i<sparkCount;i++){
        const s = sparks[i];
        s.life -= dt; if (s.life<=0) continue;
        s.vx *= drag; s.vy = s.vy*drag + SP.GRAV*dt;
        s.x += s.vx*dt; s.y += s.vy*dt;
        if (s.y>=top && s.y<=top+2 && s.vy>0 && s.x>=rect.x && s.x<=rect.x+rect.w){
          s.y = top-0.1; s.vy *= -SP.BOUNCE; s.vx *= 0.9;
        }
        if (s.x<-200 || s.x>W+200 || s.y<-200 || s.y>H+300) continue;

        const spd = Math.hypot(s.vx,s.vy);
        const len = Math.max(8, spd*0.055 * (cutMode?CUT.STREAK_GAIN:1));
        const th  = Math.max(2, s.size*2 * (cutMode?CUT.SIZE_GAIN:1));
        const ang = Math.atan2(s.vy,s.vx);

        g.translate(s.x,s.y); g.rotate(ang);

        // brighter flash layer (quick fade)
        g.globalAlpha = Math.max(0, Math.min(1, s.life*1.15 * (cutMode?CUT.CORE_GAIN:1)));
        g.drawImage(sparkSprite, -len*0.75, -th*1.1, len*1.5, th*2.2);

        // core layer
        g.globalAlpha = Math.max(0, Math.min(1, s.life * (cutMode?CUT.CORE_GAIN:1)));
        g.drawImage(sparkSprite, -len*0.45, -th*0.6, len*0.9, th*1.2);

        g.setTransform(1,0,0,1,0,0);
        sparks[write++] = s;
      }
      sparkCount = write;
      g.restore();
    }

    function newSpark(x,y,vx,vy,life,size,cut=false){
      if (sparkCount >= SP.MAX) return;
      sparks[sparkCount++] = {x,y,vx,vy,life,size,cut};
    }

    function makeSparkSprite(){
      const S=90, cv=document.createElement('canvas'); cv.width=cv.height=S;
      const c=cv.getContext('2d');
      const g=c.createRadialGradient(S/2,S/2,1, S/2,S/2,S/2);
      g.addColorStop(0,'rgba(255,255,255,1)');
      g.addColorStop(0.10,'rgba(255,255,255,0.95)');
      g.addColorStop(0.28,'rgba(230,255,245,0.85)');
      g.addColorStop(0.5,'rgba(140,255,210,0.55)');
      g.addColorStop(1,'rgba(140,255,210,0)');
      c.fillStyle=g; c.beginPath(); c.arc(S/2,S/2,S/2,0,Math.PI*2); c.fill();
      return cv;
    }

    /* ================= Visual Bits ================= */
    function drawLiveHit(g,x,y,r){
      g.save();
      g.globalCompositeOperation='lighter';
      const gr = g.createRadialGradient(x,y,0,x,y,r);
      gr.addColorStop(0,'rgba(255,255,255,1)');
      gr.addColorStop(0.35,'rgba(155,255,210,0.8)');
      gr.addColorStop(1,'rgba(0,0,0,0)');
      g.fillStyle=gr;
      g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill();
      g.restore();
    }

    /* ================= Geometry ================= */
    function buildRectPath(r, step){
      const pts = [
        [r.x,     r.y],
        [r.x+r.w, r.y],
        [r.x+r.w, r.y+r.h],
        [r.x,     r.y+r.h],
        [r.x,     r.y]
      ];
      return densify(pts, step);
    }

    function makeSideAnchors(r, nPerSide){
      const left = Array.from({length:nPerSide}, (_,i)=>({x:r.x, y:r.y + (i+0.5)*r.h/nPerSide}));
      const right= Array.from({length:nPerSide}, (_,i)=>({x:r.x+r.w, y:r.y + (i+0.5)*r.h/nPerSide}));
      const top  = Array.from({length:Math.max(2,Math.floor(nPerSide/2))}, (_,i)=>({x:r.x + (i+0.5)*r.w/Math.max(2,Math.floor(nPerSide/2)), y:r.y}));
      return left.concat(right, top);
    }
    function randomSideAnchor(anchors){ return anchors[Math.floor(Math.random()*anchors.length)]; }

    function randomPointInRect(r){
      return { x: r.x + Math.random()*r.w, y: r.y + Math.random()*r.h };
    }

    function pickRandomTextPoint(r, alphaData, maxTries=20){
      for (let tries=0; tries<maxTries; tries++){
        const px = r.x + Math.random()*r.w;
        const py = r.y + Math.random()*r.h;
        if (alphaAt(px,py,alphaData,W,H) > 5) return {x:px, y:py};
      }
      return null;
    }

    function gaussianUpperPolyline(samples, box){
      const pts=[];
      for (let i=0;i<samples;i++){
        const x = -3 + 6*(i/(samples-1));
        const y = Math.exp(-0.5*x*x);
        const sx = box.x + ((x+3)/6)*box.w;
        const sy = box.y + box.h - y*box.h;
        pts.push([sx,sy]);
      }
      return pts;
    }
    function densify(pts, step=2){
      const out=[];
      for (let i=0;i<pts.length-1;i++){
        const [x0,y0]=pts[i], [x1,y1]=pts[i+1];
        const dx=x1-x0, dy=y1-y0, len=Math.hypot(dx,dy);
        const n = Math.max(1, Math.floor(len/step));
        for (let s=0;s<n;s++){
          const t=s/n;
          out.push([x0+dx*t, y0+dy*t]);
        }
        out.push(pts[i+1]);
      }
      return out;
    }
    function polygonCentroid(pts){
      let sx=0,sy=0; for (const p of pts){ sx+=p[0]; sy+=p[1]; }
      return {x:sx/pts.length, y:sy/pts.length};
    }
    function tangentAt(path, i){
      const N = path.length;
      const i0 = Math.max(0, Math.min(N-1, i-1));
      const i1 = Math.max(0, Math.min(N-1, i+1));
      const [x0,y0] = path[i0];
      const [x1,y1] = path[i1];
      const dx=x1-x0, dy=y1-y0, m=Math.hypot(dx,dy)||1;
      return [dx/m, dy/m];
    }
    function segAt(path, prog){
      const N = path.length;
      const idxf = clamp(0, N-1, prog*(N-1));
      let i = Math.floor(idxf);
      if (i >= N - 1) i = N - 2;
      const tt = clamp(0, 1, idxf - i);
      const [x0,y0] = path[i], [x1,y1] = path[i+1];
      return { i, tt, x0, y0, x1, y1 };
    }

    /* ================= Utils ================= */
    function mk(w,h){ const c=document.createElement('canvas'); c.width=w; c.height=h; return c; }
    function inset(r,l,t,ri,b){ return {x:r.x+l, y:r.y+t, w:r.w-l-ri, h:r.h-t-b}; }
    function rr(g,x,y,w,h,r){ g.beginPath(); g.moveTo(x+r,y); g.arcTo(x+w,y,x+w,y+h,r); g.arcTo(x+w,y+h,x,y+h,r); g.arcTo(x,y+h,x,y,r); g.arcTo(x,y,x+w,y,r); g.closePath(); }
    function inside(x,y,r){ return x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h; }
    function alphaAt(x,y,data,w,h){
      const xi = Math.max(0, Math.min(w-1, Math.round(x)));
      const yi = Math.max(0, Math.min(h-1, Math.round(y)));
      const idx = yi*w*4 + xi*4 + 3;
      return data[idx] || 0;
    }
    function rand(a,b){ return a + Math.random()*(b-a); }
    function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }
    function clamp(a,b,c){ return Math.max(a, Math.min(b, c)); }
    function noise1d(x){ const i=Math.floor(x), f=x-i, u=f*f*(3-2*f); return lerp(hash(i), hash(i+1), u); }
    function hash(n){ return fract(Math.sin(n*127.1)*43758.5453123); }
    function fract(x){ return x - Math.floor(x); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function easeOutCubic(x){ return 1 - Math.pow(1 - x, 3); }

  })();
  </script>
</body>
</html>
