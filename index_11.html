<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Laser Etch â€” Gaussian Loop + Persistent Laser + Chill Sparks</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{ --bg:#0a0c10; --slab:#0c0d10; --frame:#13151a; }
  html,body{margin:0;height:100%;background:var(--bg);color:#e9fff5;font:14px/1.25 ui-monospace,Consolas,Menlo,monospace}
  .wrap{display:grid;place-items:center;min-height:100%}
  canvas{display:block;width:min(100vw,1280px);height:auto;max-height:92vh;border-radius:12px;box-shadow:0 18px 60px rgba(0,0,0,.45)}
  .hud{position:fixed;left:50%;top:10px;transform:translateX(-50%);
        background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.08);
        padding:6px 10px;border-radius:8px;color:#bfffe9;font:13px Consolas,monospace;}
  .passbig{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
        font:700 52px/1 Consolas,monospace;color:#bfffe9;opacity:.15;pointer-events:none;text-shadow:0 0 18px rgba(80,255,180,.35);}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="c" width="1280" height="720"></canvas>
</div>
<div class="hud" id="hud">Pass: 1 / 3</div>
<div class="passbig" id="passbig">PASS 1</div>

<script>
(() => {
  const MAX_PASSES = 3;
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const hud = document.getElementById('hud');
  const passBig = document.getElementById('passbig');

  const art  = mk(W,H), artCtx  = art.getContext('2d');
  const slab = mk(W,H), slabCtx = slab.getContext('2d');
  const glow = mk(W,H), glowCtx = glow.getContext('2d');
  const etch = mk(W,H), etchCtx = etch.getContext('2d');

  const P = { speed: 0.25, kerf: 6, powerFloor: 0.4, revealLen: 40, revealWidth: 22 };
  const COL = {
    slab:'#0c0d10', frame:'#13151a',
    laserCore:'rgb(230,255,245)', laserHalo:'rgb(30,255,170)',
    sparkCore:'rgb(220,255,240)'
  };

  const rect = {x:W*0.12, y:H*0.18, w:W*0.76, h:H*0.64};
  const bbox = inset(rect, rect.w*0.08, rect.h*0.12, rect.w*0.08, rect.h*0.16);
  const gantryY = rect.y - 60;

  paintArt(artCtx);
  slabCtx.fillStyle = COL.slab; rr(slabCtx, rect.x, rect.y, rect.w, rect.h, 12); slabCtx.fill();

  const upper = gaussianUpperPolyline(650, bbox);
  const upperPath = densify(upper, 2);
  const baseY = bbox.y + bbox.h;
  const basePts = [];
  for (let i=upperPath.length-1;i>=0;i--) basePts.push([upperPath[i][0], baseY]);
  const closed = upperPath.concat(densify(basePts,3));
  const N = closed.length;
  const U = upperPath.length;
  const centroid = polygonCentroid(closed);

  etchCtx.lineCap='round'; etchCtx.lineJoin='round';
  etchCtx.shadowColor='rgba(60,255,180,0.8)'; etchCtx.shadowBlur=16;
  etchCtx.strokeStyle='rgba(210,255,235,0.95)'; etchCtx.lineWidth=3;

  const SP = {
    MAX_SPARKS: 3000, EMIT_RATE: 2200, SIZE:[1.1,3.2], TRAIL_SECS:0.060,
    GRAVITY:980, DRAG:0.995, LIFETIME:[0.6,1.4],
    SPEED_TAN:[240,560], SPEED_NRM:[-260,260], JITTER:[-40,40],
    BOUNCE_E:0.35
  };

  const sparkSprite = makeSparkSprite();
  const sparks = new Array(SP.MAX_SPARKS);
  let sparkCount = 0;

  let last = performance.now();
  let progress = 0, pass = 0;
  let lastEtchIdx = null, lastLaser = null;
  let running = true, finished = false;

  hudUpdate();
  requestAnimationFrame(loop);

  function loop(now){
    const dt = Math.min((now - last)/1000, 0.1);
    last = now;
    glowCtx.clearRect(0,0,W,H);

    if (!finished){
      progress += P.speed*dt;
      while (progress >= 1){
        progress -= 1; pass++;
        lastEtchIdx = null; lastLaser = null;
        hudUpdate();
        if (pass >= MAX_PASSES){ finished = true; passBig.textContent='FINAL'; break; }
      }
    }

    // Position
    const idxf = progress*(N-1);
    const i = Math.floor(idxf);
    const tt = idxf - i;
    const [x0,y0]=closed[i],[x1,y1]=closed[(i+1)%N];
    let lx = finished ? rect.x+40 : x0+(x1-x0)*tt;
    let ly = finished ? rect.y+rect.h-40 : y0+(y1-y0)*tt;

    const t = now*0.001;
    const power = clamp(P.powerFloor,1,0.9+0.35*(noise1d(t*11.7)*0.6+noise1d(t*3.9)*0.4));
    const widthCore = 1.6+0.8*(noise1d(t*7.3)*0.5+0.5);

    // draw beam
    const gx = clamp(rect.x-60, rect.x+rect.w+60, lx);
    drawBeam(glowCtx, gx, gantryY, lx, ly, widthCore, power);

    // sparks
    const emitFactor = finished ? 0.5 : 1;
    if (!finished && i < U-1 || finished){
      const [tx,ty]=tangentAt(closed,i), nx=-ty, ny=tx;
      const want = SP.EMIT_RATE*power*dt*emitFactor;
      const emitCount = Math.min(Math.floor(want+Math.random()),SP.MAX_SPARKS-sparkCount);
      for(let s=0;s<emitCount;s++){
        const vTan=rand(...SP.SPEED_TAN), vNrm=rand(...SP.SPEED_NRM);
        const jx=rand(...SP.JITTER), jy=rand(...SP.JITTER);
        const vx=tx*vTan+nx*vNrm+jx, vy=ty*vTan+ny*vNrm+jy;
        const life=rand(...SP.LIFETIME), size=rand(...SP.SIZE);
        newSpark(lx,ly,vx,vy,life,size);
      }
    }
    renderSparks(glowCtx, dt);

    if (!finished) traceEtch(i,tt,lx,ly);

    composeFrame();
    if (running) requestAnimationFrame(loop);
  }

  function traceEtch(i,tt,lx,ly){
    const prev=lastLaser??{idx:i+tt,x:lx,y:ly};
    const fromIdx=prev.idx,toIdx=i+tt;
    for(let s=1;s<=12;s++){
      const k=lerp(fromIdx,toIdx,s/12);
      const ki=Math.floor(clamp(0,N-2,k)),kt=k-ki;
      const [ax,ay]=closed[ki],[bx,by]=closed[ki+1];
      const sx=ax+(bx-ax)*kt,sy=ay+(by-ay)*kt;
      if(ki<U-1){
        etchCtx.beginPath();
        if(lastEtchIdx==null) etchCtx.moveTo(sx,sy);
        else if(ki<lastEtchIdx||ki-lastEtchIdx>50) etchCtx.moveTo(sx,sy);
        else {const [px,py]=upperPath[lastEtchIdx]; etchCtx.moveTo(px,py);}
        etchCtx.lineTo(sx,sy); etchCtx.stroke(); lastEtchIdx=ki;
      } else lastEtchIdx=null;
    }
    lastLaser={idx:i+tt,x:lx,y:ly};
  }

  function renderSparks(g,dt){
    g.save(); g.globalCompositeOperation='lighter';
    const drag=Math.pow(SP.DRAG,dt*60); const top=rect.y;
    let write=0;
    for(let idx=0;idx<sparkCount;idx++){
      const s=sparks[idx]; s.life-=dt; if(s.life<=0) continue;
      s.vx*=drag; s.vy=s.vy*drag+SP.GRAVITY*dt;
      s.x+=s.vx*dt; s.y+=s.vy*dt;
      if(s.y>=top&&s.y<=top+2&&s.vy>0&&s.x>=rect.x&&s.x<=rect.x+rect.w){
        s.y=top-0.1; s.vy*=-SP.BOUNCE_E; s.vx*=0.9;
      }
      if(s.x<-200||s.x>W+200||s.y<-200||s.y>H+300) continue;
      const sp=Math.hypot(s.vx,s.vy), len=Math.max(8,sp*SP.TRAIL_SECS);
      const thick=Math.max(2,s.size*2.2), ang=Math.atan2(s.vy,s.vx);
      g.translate(s.x,s.y); g.rotate(ang);
      g.globalAlpha=Math.max(0,Math.min(1,s.life));
      g.drawImage(sparkSprite,-len*0.7,-thick*1.2,len*1.4,thick*2.4);
      g.globalAlpha=Math.max(0,Math.min(1,s.life*1.2));
      g.drawImage(sparkSprite,-len*0.5,-thick*0.6,len*1.0,thick*1.2);
      g.setTransform(1,0,0,1,0,0);
      sparks[write++]=s;
    }
    sparkCount=write; g.restore();
  }

  function newSpark(x,y,vx,vy,life,size){
    if(sparkCount>=SP.MAX_SPARKS)return;
    sparks[sparkCount++]={x,y,vx,vy,life,size};
  }

  function composeFrame(){
    ctx.drawImage(art,0,0); ctx.drawImage(slab,0,0);
    ctx.globalCompositeOperation='screen'; ctx.drawImage(etch,0,0);
    ctx.globalCompositeOperation='lighter'; ctx.drawImage(glow,0,0);
    ctx.globalCompositeOperation='source-over';
    ctx.strokeStyle=COL.frame; ctx.lineWidth=1.2;
    rr(ctx,rect.x,rect.y,rect.w,rect.h,12); ctx.stroke();
  }

  function hudUpdate(){ hud.textContent=`Pass: ${Math.min(pass+1,MAX_PASSES)} / ${MAX_PASSES}`; }

  function makeSparkSprite(){
    const S=96,cv=document.createElement('canvas');cv.width=cv.height=S;
    const c=cv.getContext('2d');const g=c.createRadialGradient(S/2,S/2,1,S/2,S/2,S/2);
    g.addColorStop(0,'rgba(255,255,255,1.0)');
    g.addColorStop(0.15,'rgba(230,255,245,0.95)');
    g.addColorStop(0.4,'rgba(120,255,200,0.55)');
    g.addColorStop(1,'rgba(120,255,200,0.0)');
    c.fillStyle=g;c.beginPath();c.arc(S/2,S/2,S/2,0,Math.PI*2);c.fill();return cv;
  }

  function drawBeam(g,x0,y0,x1,y1,w,p){
    g.save(); g.globalCompositeOperation='lighter';
    g.strokeStyle=withAlpha(COL.laserHalo,0.35*p);
    g.lineWidth=w+6; g.lineCap='round';
    g.beginPath();g.moveTo(x0,y0);g.lineTo(x1,y1);g.stroke();
    g.strokeStyle=withAlpha(COL.laserCore,Math.max(0.05,p));
    g.lineWidth=w; g.beginPath();g.moveTo(x0,y0);g.lineTo(x1,y1);g.stroke();
    g.fillStyle=withAlpha(COL.laserHalo,0.65);
    for(let i=0;i<3;i++){g.beginPath();g.arc(x1,y1,6+i*6,0,Math.PI*2);g.fill();}
    g.restore();
  }

  function paintArt(g){
    const grad=g.createLinearGradient(0,0,W,H);
    grad.addColorStop(0,'#102b1e');grad.addColorStop(1,'#3bd6a6');
    g.fillStyle=grad;g.fillRect(0,0,W,H);
    g.globalAlpha=0.18;g.strokeStyle='#fff';
    for(let x=0;x<=W;x+=40){g.beginPath();g.moveTo(x,0);g.lineTo(x,H);g.stroke();}
    for(let y=0;y<=H;y+=40){g.beginPath();g.moveTo(0,y);g.lineTo(W,y);g.stroke();}
    g.globalAlpha=1;g.fillStyle='rgba(235,255,245,0.95)';
    g.font='bold 46px Consolas,monospace';g.textAlign='center';g.textBaseline='middle';
    g.fillText('Bayesian Modeling & Inference',W/2,H*0.14);
  }

  function gaussianUpperPolyline(samples,box){
    const pts=[];for(let i=0;i<samples;i++){
      const x=-3+6*(i/(samples-1)),y=Math.exp(-0.5*x*x);
      const sx=box.x+((x+3)/6)*box.w,sy=box.y+box.h - y*box.h;
      pts.push([sx,sy]);}
    return pts;
  }
  function densify(pts,step=2){
    const out=[];for(let i=0;i<pts.length-1;i++){
      const[x0,y0]=pts[i],[x1,y1]=pts[i+1];const dx=x1-x0,dy=y1-y0,len=Math.hypot(dx,dy);
      const n=Math.max(1,Math.floor(len/step));
      for(let s=0;s<n;s++){const t=s/n;out.push([x0+dx*t,y0+dy*t]);}}
    out.push(pts.at(-1));return out;
  }
  function polygonCentroid(pts){let sx=0,sy=0;for(const p of pts){sx+=p[0];sy+=p[1];}
    return{x:sx/pts.length,y:sy/pts.length};}
  function tangentAt(path,i){const i0=Math.max(0,i-1),i1=Math.min(path.length-1,i+1);
    const[x0,y0]=path[i0],[x1,y1]=path[i1];const dx=x1-x0,dy=y1-y0,m=Math.hypot(dx,dy)||1;
    return[dx/m,dy/m];}
  function mk(w,h){const c=document.createElement('canvas');c.width=w;c.height=h;return c;}
  function inset(r,l,t,ri,b){return{x:r.x+l,y:r.y+t,w:r.w-l-ri,h:r.h-t-b};}
  function rr(g,x,y,w,h,r){g.beginPath();g.moveTo(x+r,y);g.arcTo(x+w,y,x+w,y+h,r);
    g.arcTo(x+w,y+h,x,y+h,r);g.arcTo(x,y+h,x,y,r);g.arcTo(x,y,x+w,y,r);g.closePath();}
  function rand(a,b){return a+Math.random()*(b-a);}
  function clamp(a,b,c){return Math.max(a,Math.min(b,c));}
  function lerp(a,b,t){return a+(b-a)*t;}
  function withAlpha(rgb,a){return rgb.replace('rgb(','rgba(').replace(')',','+a.toFixed(3)+')');}
  function noise1d(x){const i=Math.floor(x),f=x-i,u=f*f*(3-2*f);return lerp(hash(i),hash(i+1),u);}
  function hash(n){return fract(Math.sin(n*127.1)*43758.5453123);}
  function fract(x){return x-Math.floor(x);}
})();
</script>
</body>
</html>
